# 1. 并发基本概念及实现，进程，线程基本概念
## 1.1 并发，进程，线程的基本概念
* 并发
* 可执行程序
* 进程  
    运行中的可执行程序，
* 线程  
  * 每个进城都有一个主线程，一个进程中有且仅有一个主线程
  * 主线程随进程产生而产生，由主线程执行`main`函数代码
  * 可以创建不同的线程可以执行不同的任务
  * 线程并不是越多越好，每个线程都需要独立独立的堆栈空间，线程间切换频繁CPU使用效率降低
## 1.2 并发的实现方法
* 多进程并发  
进程间通信：管道，文件，消息队列，共享内存，Socket通信

* 多线程并发  
    轻量级的进程，一个进程中的所有的线程共享地址空间（共享内存），全局变量等可以在多线程之间传递。使用多线程开销远小于多进程  
    数据一致性问题
* 优先考虑使用多线程技术
  * 线程启动速度更快，更轻量级
  * 系统资源开销更小，执行速度更快，通信可以共享内存方式
  * 使用时需注意处理数据一致性问题
## 1.3 C++11新标准线程库
C++语言本身对多线程的支持，可以编写跨平台的代码，减少了开发人员的工作量

# 2. 线程启动，结束
## 2.1 基本使用

## 2.2 lambda表达式

# 3. 线程传参详解
## 3.1 临时对象做线程参数
* 传递基本类型参数，建议使用值传递  
* 传递自定义类型参数，建议使用引用类型传参
> 不建议使用detach()方法，就不需要考虑被引用的变量先销毁的情况

**线程ID**
* 每个线程都用线程Id标识
## 3.2 类对象、智能指针作为线程参数
* `std::ref()`传递对象的真引用
* 参数为智能指针时，需使用`std::move()`转换

## 3.3 成员函数指针作为线程参数
* 使用`std::ref()`

# 4. 多线程共享数据问题
## 4.1 创建多个线程

## 4.2 数据共享问题
* 只读数据是共享安全的
* 读写共享数据需要加锁

# 5. 互斥量、死锁
## 5.1  互斥量
一个类对象，一把🔐，多个线程尝试用`lock()`尝试加锁，只有一个线程可以加锁成功，如果没有加锁成功，则会阻塞等待加锁
* 只保护需要保护的数据
* 有`lock()`必然要有`unlock()`

## 5.2 死锁
* 至少存在两把锁才会发生死锁问题
* 解决方案：
  * 保证两个互斥量的加锁顺序一致
  * `std::lock()`一次可以加锁多个互斥量，且不会导致死锁问题。如果一个互斥量加锁失败，释放已加锁的互斥量。**但是仍然需要`unlock()`，可以结合`std::adopt`使用**

# 6. unique_lock
* `std::adopt_lock()`：标识该锁已经lock，需先加锁
* `std::try_to_lock()`：加锁失败，立即返回，不能先lock
* `std::defer_lock()`：不能提前lock，初始化一个没有加锁的mutex

**`unique_lock`的成员函数**
* `lock()`
* `unlock()`
* `try_lock()`
* `release()`：解锁和mutex之间的关系

**`unique_lock`所有权的传递**

# 7. 单例设计模式共享数据分析，call_once
## 7.1 单例设计模式

单例：整个项目中，有某个或者某些特殊的类只能创建一个对象


## 7.2 单例模式共享数据问题


## 7.3 `std::call_once()`
* 保证某个函数只调用一次，比互斥量更高效，消耗资源更少
* 通过与标记`std::once_flag()`配合使用